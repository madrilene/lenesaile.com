---
title: '√úber subgrid und farbige Rasterlinien'
description: 'F√ºr mich war das subgrid immer das, was mir fehlte, um grid wirklich in meine workflows zu integrieren. In diesem Artikel versuche ich, einen Prototyp f√ºr ein Design aufzubauen, das ein vierspaltiges Layout mit farbigen Rasterlinien erfordert.'
discover:
  description: 'Ich versuche einen Prototyp f√ºr ein Design aufzubauen, das ein vierspaltiges Layout mit farbigen Rasterlinien erfordert - mit subgrid.'
category: blogpost
key: 'subgrid'
date: 2023-11-15 15:20:00
lastEdit: 2023-12-27 09:50:00
---

F√ºr mich war das subgrid immer das, was mir fehlte, um grid wirklich in meine workflows zu integrieren.

Mit [CSS grid](https://developer.mozilla.org/en-US/docs/Web/CSS/grid) k√∂nnen "row" und "column tracks", die in einem √ºbergeordneten Raster (`grid`) erstellt wurden, nur f√ºr die Positionierung der direkten Kinder des Raster-Containers verwendet werden. Subgrid erm√∂glicht die gemeinsame Nutzung aller im √ºbergeordneten grid festgelegten Werte.

Anstatt die "line names" und "track sizing functions" explizit zu definieren, verwenden wir das Schl√ºsselwort `subgrid` als Wert f√ºr `grid-template-columns` oder `grid-template-rows`, um den "grid track" vom n√§chstgelegenen grid zu erben.

Zum Beispiel k√∂nnte ein klassisches 12-Spalten-Raster √ºbergeordnet f√ºr die gesamte Seite erstellt werden, und wir k√∂nnen dann unsere Elemente darin anordnen, egal wie tief sie verschachtelt sind. Du kannst die derzeitige [Browser-Unterst√ºtzung f√ºr CSS Subgrid auf caniuse.com](https://caniuse.com/?search=subgrid) nachsehen.

{% include "partials/toc.njk" %}

## Vorbereitung

F√ºr ein neues Projekt liegt mir ein Entwurf vor, der f√ºr Subgrid wie gemacht zu sein scheint: Die Seite ist in vier Spalten innerhalb eines Wrappers unterteilt. Die vier Spalten sind sichtbar durch 1px breite vertikale Linien geteilt, die vom oberen Rand der Seite bis zum unteren Rand verlaufen. Alle Elemente und Inhalte sind direkt an diesen Linien ausgerichtet, einige Inhalte sind √ºber mehrere Spalten verteilt, andere beginnen erst an einer bestimmten Rasterlinie.

### Einrichten des HTML

Zum Testen habe ich folgenedes HTML geschrieben:

{% raw %}

```html
<body>
  <div class="wrapper">
    <header class="landmark">
      <h1>Biscuit!</h1>
      <svg><!-- ... --></svg>
    </header>
    <main class="landmark">
      <article class="chocolate">
        <h2>Chocolate cake</h2>
        <p>Cookie tart cake cotton candy chocolate chocolate.</p>
        <section>
          <h3>Jelly beans</h3>
          <p>
            Jelly beans gummi bears halvah halvah croissant lemon drops donut gummi bears
            candy canes. Icing sugar plum chupa chups jelly-o souffl√© jelly-o pudding
            lollipop. Chocolate bar muffin bonbon pie tootsie roll danish bear claw
            cheesecake.
          </p>
        </section>
        <section>
          <h3>Cheesecake</h3>
          <p>Powder halvah souffl√© caramels souffl√© chocolate cake halvah.</p>
        </section>
        <section>
          <!-- ... -->
        </section>
        <section>
          <!-- ... -->
        </section>
      </article>
    </main>
    <footer class="landmark">
      <p>
        Diving into subgrid. Created and maintained by
        <a href="#">Lene</a>
      </p>
      <nav>
        <ul role="list">
          <li>
            <a href="#">RSS Feed</a>
          </li>
          <li>
            <a href="#">Follow</a>
          </li>
        </ul>
      </nav>
      <p>Crafted with semantic HTML.</p>
    </footer>
  </div>
</body>
```

{% endraw %}

{% asideInfo %}Ich habe hier und in allen folgenden Beispielen auf Codepen unn√∂tigerweise ein `div` zwischen `<body>` und die drei landmarks `<header>`, `<main>` und `<footer>` gesetzt. Diese sollten aber direkte Kinder von `<body>` sein, [um von screen readern richtig interpretiert zu werden](https://webaim.org/techniques/semanticstructure/#regions). Solltet ihr die folgenden Versuche irgendwo einbauen wollen, nehmt am besten das `div` raus und setzt das Eltern-grid direkt auf `<body>`.{% endasideInfo %}

### Das "√ºbergeordnete" grid-System

Zun√§chst lege ich die Abmessungen f√ºr den Wrapper fest.

```css
.wrapper {
  inline-size: clamp(16rem, 93vw, 120rem);
  margin-inline: auto;
  position: relative;
}
```

Dieser Wrapper soll mein seitenweites Grid-System aufnehmen. Ich m√∂chte jedoch meine Wrapper-Klasse unangetastet lassen, sie soll sich nur um das k√ºmmern, was ihr Name impiziert.

Mein `<body>`-Element hat ein direktes `child` Element, n√§mlich meinen Wrapper. Ich benutze diesen Selektor, um das Gittersystem separat zu definieren (eine neue Klasse mit einem entsprechenden Namen w√§re auch eine Option).

```css
body > div {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
}
```

Nun wird der Wrapper in vier gleichgro√üe Spalten aufgeteilt, die ohne Zwischenraum direkt nebeneinander platziert werden.

{% set slug = "yLZoZgE" %}
{% set caption = "Subgrid mit Linien: Standardansicht" %}
{% include "partials/codepen.njk" %}

Der Wrapper hat drei `child` Elemente, die nun jeweils in den ersten drei Spalten platziert werden. Dies ist ihr nat√ºrliches Verhalten, da sie `child` Elemente eines grids sind und sich selbst in die verf√ºgbaren Spuren aufteilen.

### Subgrid aktivieren

Ich m√∂chte, dass alle drei Orientierungspunkte das √ºbergeordnete Raster f√ºr sich selbst erhalten.

**Aktivieren wir subgrid!**

```css
:is(header, main, footer).landmark {
  display: grid;
  grid-template-columns: subgrid;
}
```

Das funktioniert noch nicht. Ich kann in den Dev-Tools sehen, dass das Subgrid aktiv ist, aber alle drei sind immer noch in einer Spalte stecken geblieben.

{% image "./src/assets/images/blog/subgrid-devtools.jpg", "Ausschnitt aus dem DOM der Firefox Developer Tools. Es zeigt das body-Element des Dokuments und sein child-Element, ein div mit einer wrapper-Klasse. Dem untergeordnet sind die drei 'landmarks' header, main und footer. Der Wrapper ist als Grid gekennzeichnet, die drei 'landmarks' als Subgrid.", "Screenshot des Inspektor-Tabs der Firefox-Entwicklerwerkzeuge" %}

Das liegt daran, dass sie immer noch direkte `child` Elemente des √ºbergeordneten Rastersystems sind.

Stattdessen m√∂chte ich, dass sie die gesamte Breite des Wrappers einnehmen und werde daher angeben, welche Spalten des √ºbergeordneten Rasters sie genau einnehmen sollen:

```css
:is(header, main, footer).landmark {
  display: grid;
  grid-template-columns: subgrid;
  grid-column: 1 / -1;
}
```

{% set slug = "zYeEJKw" %}
{% set caption = "Subgrid mit Linien: subgrid aktiviert" %}
{% include "partials/codepen.njk" %}

Jetzt √ºbernehmen unsere drei <span lang="en">"landmarks"</span> das grid ihres Vorfahren und platzieren ihre eigenen `child` Elemente darin! Nur `<main>` erstreckt sich √ºber alle Spalten, sortiert seine Elemente aber trotzdem nur in die erste Spalte. Darauf kommen wir gleich noch zu sprechen.

Wenn ich einen Blick auf die <span lang="en">developer tools</span> werfe, kann ich auch sehen, dass drei <span lang="en">"rows"</span> automatisch erstellt wurden.

Es lohnt sich, einen genauen Blick auf die <span lang="en">developer tools</span> f√ºr CSS Grid zu werfen: Wenn die Seite ein Grid mit einem Subgrid enth√§lt, wird in Firefox der Eintrag f√ºr das Subgrid unter seinem Parent im Overlay Grid Abschnitt einger√ºckt.

{% image "./src/assets/images/blog/subgrid-devtools-details.jpg", "Screenshot, der die Checkboxen f√ºr das Overlay-Grid und die Grid-Anzeigeeinstellungen zeigt, um Linien f√ºr ein Subgrid oder ein Parent-Grid sichtbar zu machen. Das Wrapper-Gitter ist ausgew√§hlt.", "Screenshot der Firefox-Entwicklerwerkzeuge: CSS-Fenster, Layout-Ansicht, Raster-Abschnitt." %}

{% asideInfo %}Wenn du mehr dar√ºber wissen willst: [Firefox docs for the CSS Grid Inspector, chapter "Examine grid layouts"](https://firefox-source-docs.mozilla.org/devtools-user/page_inspector/how_to/examine_grid_layouts/index.html).{% endasideInfo %}

## Platzieren von Elementen im Raster

Standardm√§√üig werden die untergeordneten Elemente auf der ersten verf√ºgbaren Rasterlinie platziert.

### header

Um das `anchor`-Element im `<header>` muss ich mich vorerst nicht k√ºmmern.

Aber gem√§√ü dem Design sollte sich das SVG an der vierten Rasterlinie ausrichten. Ich erreiche dies, indem ich mich generell an der letzten Spaltenzeile ausrichte:

```css
header.landmark svg {
  grid-column-start: -1;
}
```

### main

W√§hrend `<main>` ein subgrid ist, ist sein Kind `<article>` keines: es herrscht das normale Fluslayout. Aus irgendeinem Grund hatte ich das Gef√ºhl, dass ich Subgrid sparsam verwenden sollte. Aber daf√ºr gibt es eigentlich keinen Grund. Also mache ich alle `<article>`-Elemente, die direkte `child`-Elemente von `<main>` sind, ebenfalls zu subgrids!

```css
main.landmark > article {
  display: grid;
  grid-template-columns: subgrid;
  grid-column: 1 / -1;
}
```

{% asideInfo %}Zu beachten ist, dass die ausgew√§hlten Artikelelemente _nicht_ subgrids von `<main>` sind, sondern immer vom n√§chstliegenden Vorg√§ngerelement, das ein <span lang="en">column template</span> definiert, das _nicht_ subgegridded (Entschuldigung üôè) ist. Das ist unser Wrapper `<div>`, ausgew√§hlt √ºber `body > div`.{% endasideInfo %}

Wenn ich mir den Entwurf ansehe, sollten der Titel und der Absatz des `<article>` nicht im normalen Raster platziert werden, sondern jeweils eine eigene Zeile in der ersten Spalte einnehmen.

```css
main.landmark > article > p {
  grid-row: 2;
}
```

Die Abschnitte in `<main>` sind auf verschiedene Spalten im Desktop-Design verteilt. Ich platziere sie jetzt explizit in der ihnen zugewiesenen Zeile und Spalte. In unserem Beispiel gibt es nur Abschnitte innerhalb von `main.landmark`, aber im Hinblick auf zuk√ºnftige Kompatibilit√§t wird `<main>` weitere `<article>`-Elemente in einem erweiterten HTML beherbergen.

```css
article.work > section:first-of-type {
  grid-column: 2 / -1;
  grid-row: 3;
}

article.work > section:nth-of-type(2) {
  grid-column: 3 / -1;
  grid-row: 4;
}

article.work > section:nth-of-type(3) {
  grid-column: span 1 / -1;
  grid-row: 5;
}

article.work > section:last-of-type {
  grid-column: 3 / -1;
  grid-row: 6;
}
```

### footer

Ich m√∂chte auch Elemente in ihrer eigenen Zeile im `<footer>` platzieren. Ich kann diese zus√§tzliche Zeile direkt in der Landmarke definieren, und zus√§tzlich zu dem oben definierten Unterraster erh√§lt sie ihren eigenen `grid-template-rows`-Wert.

{% asideInfo %}Beachte, dass szbgrids auch f√ºr `grid-template-rows` erstellt werden k√∂nnen!
Ich werde in diesem Beispiel nicht so weit gehen, aber es ist sinnvoll um Elemente zu erstellen, die ihr eigenes, sich wiederholendes Zeilenlayout innerhalb der ihnen zugewiesenen Spalte ben√∂tigen.{% endasideInfo %}

Das erste Child-Element soll sich √ºber zwei Spalten und Zeilen erstrecken, das Men√º und der letzte Pragraph werden rechts untereinander angeordnet.

```css
footer.landmark {
  grid-template-rows: repeat(2, auto);
}

footer.landmark p:first-of-type {
  grid-column: span 2;
  grid-row: 1 / -1;
}

footer.landmark p:last-of-type,
footer.landmark nav {
  grid-column: span 2 / -1;
  place-self: end;
}
```

repeat(2, auto)` bedeutet, dass es zwei Zeilen im Raster gibt, die beide die gleiche H√∂he haben sollen, die dynamisch auf der Grundlage ihres Inhalts bestimmt wird.

auto" bedeutet, dass sich die H√∂he der Zeilen automatisch an ihren Inhalt anpasst.

{% set slug = "qBgXwrK" %}
{% set caption = "subgrid with lines: placing items" %}
{% include "partials/codepen.njk" %}

## Farbige grid-Linien

Unsere Elemente sind ausgerichtet, kommen wir nun zu dem Teil, der sich zun√§chst einfach anh√∂rt: Die Spalten unseres Layouts sollen durch farbige Trennlinien markiert werden. Kann ich die grid-Linien nicht einfach einf√§rben?

Das klappt aber nicht. Ich _kann_ die Linien in den Entwicklungswerkzeugen anzeigen, aber ich scheine keine M√∂glichkeit zu haben, diese Linien tats√§chlich mit einer Farbe zu versehen. Allerdings habe ich ein paar Ans√§tze in freier Wildbahn gefunden (Sprich: Stack Overflow. Ich habe auch gewagt, Chat GTP zu fragen, aber das war v√∂llig sinnlos). Die Ans√§tze wurden nicht mit Subgrid im Hinterkopf erstellt, aber ausprobieren schadet nicht.

### Idee 1: Hinzuf√ºgen eines gap und einer background-color

Versuchen wir, einen `gap` von 1px und eine `background-color` f√ºr das √ºbergeordnete grid hinzuzuf√ºgen.

```css
body > div {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  background-color: blue;
  gap: 1px;
}
```

Anschlie√üend wird den subgrids die normale Hintergrundfarbe wieder zur√ºckgegeben.

```css
:is(header, main, footer).landmark,
main.landmark > article {
  display: grid;
  grid-template-columns: subgrid;
  grid-column: 1 / -1;
  background-color: white;
}
```

{% set slug = "WNPEPwE" %}
{% set caption = "Subgrid mit Linien lines: gap und background-color" %}
{% include "partials/codepen.njk" %}

Naja, das hat nur halbwegs funktioniert. Die <span lang="en">"intrinsically"</span> erstellten Zeilen des √ºbergeordneten grids sind blau eingef√§rbt, aber da die subgrid-container alle Spalten umfassen, sind die <span lang="en">"gaps"</span> nicht mehr sichtbar.

### Idee 2: border-color

Kann ich allen Grid-Elementen einen Rahmen zuweisen?

```css
body > div > * {
  border-inline-start: 1px solid blue;
}

body > div > *:last-of-type {
  border-inline-end: 1px solid blue;
}
```

Jetzt hat mein √ºbergeordnetes Raster rechts und links einen Rand, weil dies die Bereiche sind, die nicht √ºberlagert werden.

Was, wenn ich dies f√ºr die <span lang="en">subgrids</span> wiederhole?

```css
:is(header, main, footer).landmark > *,
main.landmark > article > * {
  border-inline-start: 1px solid blue;
}

:is(header, main, footer).landmark > *:last-of-type,
main.landmark > article > *:last-of-type {
  border-inline-end: 1px solid blue;
}
```

Jetzt habe ich ein Chaos von vertikalen Linien, die an den Seiten verdoppelt sind, weil der Rahmen nur dort angewendet wird, wo es Elemente gibt.

{% set slug = "xxMLQQr" %}
{% set caption = "Subgrid mit Linien: border" %}
{% include "partials/codepen.njk" %}

### Idee 3: background-image: linear-gradient

Mit diesem Ansatz verabschiede ich mich von dem Versuch, das grid direkt anzusprechen.

Mir ist eingefallen, dass ich ein sich wiederholendes [CSS-Muster] (https://projects.verou.me/css3patterns/#vertical-stripes) in den Hintergrund stellen k√∂nnte, da die vier Spalten v√∂llig gleichm√§√üig sind. Das w√§re wie eine grafische Ebene, die nur versucht, meine Rasterspalten nachzubilden.

Nach einigem Ausprobieren entschied ich mich f√ºr diese Variante:

```css
body > div {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  background-image: linear-gradient(to right, blue 1px, transparent 1px);
  background-size: 24.95%;
  background-repeat: repeat;
}
```

Damit wird ein linearer Farbverlauf f√ºr die Eigenschaft `background-image` festgelegt, der ein sich wiederholendes Muster aus einer blauen 1-Pixel-Linie vor einem transparenten Hintergrund erzeugt und 24,95 % der Breite des Containers abdeckt. Entschuldigung f√ºr diese beliebige Zahl (auch "[magische Zahl](<https://de.wikipedia.org/wiki/Magische_Zahl_(Informatik))>)" genannt.

{% set slug = "ExrvBYa" %}
{% set caption = "Subgrid mit Linien: linear-gradient" %}
{% include "partials/codepen.njk" %}

Es ist hacky, buggy und leicht daneben, aber gut genug im Moment. Ich bin ziemlich sicher, dass ich es noch √§ndern werde, da es nicht in jedem <span lang="en">viewport</span> ein sch√∂nes Ergebnis liefert.

Dies ist keine zufriedenstellende L√∂sung - ich hoffe, dass jemand eine bessere Idee hat und mir diese mitteilt üò¨.

## Update: Ideen aus der CSS-Gemeinschaft

Ich habe den Artikel auf Mastodon geteilt, und wie erhofft, haben sehr kompetente Menschen neue Ideen vorgeschlagen! üéâ

### linear-gradient ohne magische Zahl

[Christopher Kirk-Nielsen](https://chriskirknielsen.com/) hat sich des Problems der magischen Zahlen angenommen und meine L√∂sung in eine viel sauberere verwandelt:

```css
body > div {
  --cols: 4;
  --line-size: 1px;
  display: grid;
  grid-template-columns: repeat(var(--cols), 1fr);
  background-image: linear-gradient(to right, blue var(--line-size), transparent 0);
  background-size: calc((100% - var(--line-size)) / var(--cols));
}
```

Er hat die Anzahl der Spalten und die "Linienbreite" in Variablen gspeichert und daraus die gew√ºnschte Breite berechnet. Das Tolle daran ist, dass es jetzt eine Beziehung zwischen dem grid und dem Muster gibt, und wir k√∂nnen die Linienst√§rke (`--line-size`) und die Anzahl der Spalten (`--cols`) dynamisch anpassen - sie gelten sowohl f√ºr das zugrunde liegende Rastersystem als auch f√ºr die sichtbaren Linien.

{% set user = "chriskirknielsen" %}
{% set slug = "JjxOGEr" %}
{% set caption = "subgrid mit Linien: linear-gradient (ohne magische Zahl)" %}
{% include "partials/codepen.njk" %}

Das ist super, danke! üíö

### Pseudo-Elemente als Gitternetzlinien

[Roma Komarov] (https://kizu.dev/) hat die Idee eingebracht, zus√§tzliche leere Elemente als Platzhalter und Pseudo-Elemente als Grid-Linien zu erstellen.

Roma setzt CSS-Pseudo-Elemente vor die Child-Elemente des `<article>`-Elements und hinter das `<article>`-Element selbst.

```css
article > *::before,
article::after {
  content: '';
  position: absolute;
  /* Bewusstes Weglassen der Einf√ºgezeile unter Verwendung der "Ausgangsposition" dieser Elemente */
  inset-block: 0;
  width: 1px;
  background-color: blue;
  z-index: -1;
}

article::after {
  right: 0;
}
```

Roma weist darauf hin, dass diese Methode mehr Linien als n√∂tig erzeugt: Wenn es Elemente gibt, die auf denselben Rasterlinien beginnen, √ºberschneiden sie sich, was sichtbar wird, wenn man einen `opacity`-Wert hinzuf√ºgt:

```css
article > *::before,
article::after {
  /* alle anderen CSS-Deklarationen */
  opacity: 0.1;
}
```

{% set user = "kizu" %}
{% set slug = "MWLOaxW" %}
{% set caption = "subgrid mit Linien: Pseudo-Elemente" %}
{% include "partials/codepen.njk" %}

Danke! üíö

Roma empfiehlt, besser leere Elemente auf dem Grid zu platzieren, da jede √Ñnderung der aktuellen Position der `<article>`-Kinder im Grid die Linien verschwinden lassen kann. Das machen wir im n√§chsten Abschnitt.

### Platzhalter implementiert, mobile Ansicht

Ich habe Romas Idee aufgegriffen und die Platzhalter in einem weiteren Codepen implementiert. Au√üerdem habe ich einen "media query" f√ºr die meisten im Grid platzierten Elemente hinzugef√ºgt, damit sie sich auf mobilen Ger√§ten √ºber die gesamte Breite erstrecken (und damit die Linien auch auf kleinen Viewports "funktionieren").

Ich m√∂chte niemanden langweilen und werde hier nicht alle CSS-Anpassungen wiederholen, wenn du die Details wissen willst, wirf einen Blick auf den code in Codepen:

{% set slug = "NWowaov" %}
{% set caption = "subgrid mit Linien: Pseudo-Elemente, Platzhalter und Media Query" %}
{% include "partials/codepen.njk" %}

## Update 2: Josh Comeaus L√∂sung

Ein paar Tage sp√§ter ver√∂ffentlichte Josh Comeau einen seiner umfangreichen Artikel, _An Interactive Guide to CSS Grid_. Dort geht er nicht auf Subgrid ein, aber er auch er [tr√§gt beil√§ufig zu einer L√∂sung meines Problems bei] (https://www.joshwcomeau.com/css/interactive-guide-to-grid/#grid-construction-3).

Zur besseren Veranschaulichung seiner Beispiele hebt er die unsichtbaren Rasterlinien mit gestrichelten Linien hervor. Sein Ansatz ist √§hnlich wie der von Roma: Im Zusammenhang mit Pseudo-Elementen arbeitet er nicht mit `background-color`, sondern mit `border-left` (Ich verwende stattdessen "logical properties", `border-inline-end` oder `border-right` w√ºrden genauso funktionieren).

Seine L√∂sung hat einen anderen Anwendungsfall, so dass ich seine Version vereinfachen konnte.
Ich habe dies auf das letzte Beispiel mit den leeren Platzhaltern angewendet (die gestrichelten Linien von Josh habe ich beibehalten, um den Unterschied zur vorherigen L√∂sung deutlicher zu machen):

```css
div.placeholder > *::before,
div.placeholder::after {
  content: '';
  position: absolute;
  inset-block: 0;
  border-inline-start: 2px dashed blue;
}

div.placeholder::after {
  right: 0;
}
```

{% set slug = "yLZjKzb" %}
{% set caption = "subgrid mit Linien: Josh Comeaus pseudo-element borders" %}
{% include "partials/codepen.njk" %}

## Mehr √ºber subgrid

1. Klassiker: [mdn](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_grid_layout/Subgrid)
2. Rachel Andrew mit guten Beispielen in ihrem [Artikel f√ºr 12 Days of Web, Ausgabe 2022](https://12daysofweb.dev/2022/css-subgrid/)
3. [Artikel auf web.dev](https://web.dev/articles/css-subgrid), basierend auf der Idee eines "Makro"-Rasters auf Seitenebene
4. Gro√üartige Beispiele f√ºr Untergitter gibt es auf [gridbyexample.com](https://gridbyexample.com/examples/#css-grid-level-2-examples)
5. ["Learn CSS Subgrid"](https://ishadeed.com/article/learn-css-subgrid/) von Ahmad Shadeed
6. [Michelle Barker √ºber subrid](https://www.youtube.com/watch?v=tueTFd2TQUA&t=2266s) in ihrem "Creative CSS Layout" am CSS Day 2022 (YouTube)
7. ...und ein Buch: [CSS - The Definitive Guide](https://www.oreilly.com/library/view/css-the-definitive/9781098117603/)

Mein Partner lachte, als er mich <span lang="en">old school</span> mit einem Fachbuch vor dem Computer sitzen sah. "[CSS - The Definitive Guide](https://www.oreilly.com/library/view/css-the-definitive/9781098117603/)" ist tats√§chlich die erste Quelle, in der ich nachschaue, wenn ich etwas √ºber CSS lernen oder genauer wissen m√∂chte. Es gibt √ºber 80 Seiten allein √ºber grid, und ich kann es nur empfehlen.

{% image "./src/assets/images/blog/css-definitive-guide-grid.jpg", "Das Buch CSS - The Definitive Guide liegt aufgeschlagen auf meinem Schreibtisch in einem Kapitel √ºber subgrid, mit meiner Tastatur dahinter. " %}
